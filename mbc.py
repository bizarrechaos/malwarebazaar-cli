#!/usr/bin/env python

import requests
import json
import curses
import curses.textpad


class Screen(object):
    UP = -1
    DOWN = 1

    def __init__(self, items):
        """ Initialize the screen window"""
        self.window = None

        self.width = 0
        self.height = 0

        self.init_curses()

        self.items = items

        self.max_lines = curses.LINES
        self.top = 0
        self.bottom = len(self.items)
        self.current = 0
        self.page = self.bottom // self.max_lines

        self.selected = False

        self.download = False

    def init_curses(self):
        """Setup the curses"""
        self.window = curses.initscr()
        self.window.keypad(True)
        self.window.border()
        curses.noecho()
        curses.cbreak()

        curses.start_color()
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_BLACK, curses.COLOR_BLUE)
        curses.init_pair(3, curses.COLOR_WHITE, curses.COLOR_BLACK)

        self.current = curses.color_pair(2)

        self.height, self.width = self.window.getmaxyx()

    def run(self):
        """Continue running the TUI until get interrupted"""
        try:
            self.input_stream()
        except KeyboardInterrupt:
            pass
        finally:
            curses.endwin()

    def input_stream(self):
        """Waiting an input and run a proper method according to type of input"""
        while True:
            self.display()

            ch = self.window.getch()
            if ch == curses.KEY_UP:
                self.scroll(self.UP)
            elif ch == curses.KEY_DOWN:
                self.scroll(self.DOWN)
            elif ch == curses.KEY_LEFT:
                self.paging(self.UP)
            elif ch == curses.KEY_RIGHT:
                self.paging(self.DOWN)
            elif ch == curses.ascii.ESC:
                self.selected = False
            elif ch == 10:
                self.selected = True
            elif ch == 100:
                self.download = True

    def scroll(self, direction):
        """Scrolling the window when pressing up/down arrow keys"""
        # next cursor position after scrolling
        next_line = self.current + direction

        # Up direction scroll overflow
        # current cursor position is 0, but top position is greater than 0
        if (direction == self.UP) and (self.top > 0 and self.current == 0):
            self.top += direction
            return
        # Down direction scroll overflow
        # next cursor position touch the max lines, but absolute position of max lines could not touch the bottom
        if (direction == self.DOWN) and (next_line == self.max_lines) and (self.top + self.max_lines < self.bottom):
            self.top += direction
            return
        # Scroll up
        # current cursor position or top position is greater than 0
        if (direction == self.UP) and (self.top > 0 or self.current > 0):
            self.current = next_line
            return
        # Scroll down
        # next cursor position is above max lines, and absolute position of next cursor could not touch the bottom
        if (direction == self.DOWN) and (next_line < self.max_lines) and (self.top + next_line < self.bottom):
            self.current = next_line
            return

    def paging(self, direction):
        """Paging the window when pressing left/right arrow keys"""
        current_page = (self.top + self.current) // self.max_lines
        next_page = current_page + direction
        # The last page may have fewer items than max lines,
        # so we should adjust the current cursor position as maximum item count on last page
        if next_page == self.page:
            self.current = min(self.current, self.bottom % self.max_lines - 1)

        # Page up
        # if current page is not a first page, page up is possible
        # top position can not be negative, so if top position is going to be negative, we should set it as 0
        if (direction == self.UP) and (current_page > 0):
            self.top = max(0, self.top - self.max_lines)
            return
        # Page down
        # if current page is not a last page, page down is possible
        if (direction == self.DOWN) and (current_page < self.page):
            self.top += self.max_lines
            return

    def display(self):
        """Display the items on window"""
        self.window.erase()
        for idx, item in enumerate(self.items[self.top:self.top + self.max_lines]):
            # Highlight the current cursor line
            sha256 = item['sha256_hash']
            filetype = item['file_type']
            firstseen = item['first_seen']
            if filetype == 'unknown':
                filetype = 'None'
            tags = item['tags']
            if tags:
                tags = ', '.join(tags)
            if idx == self.current:
                self.window.addstr(idx, 0, f'{firstseen} | {sha256} | {filetype}\t| {tags}', curses.color_pair(2))
                if self.selected:
                    self.window.erase()
                    line = 0
                    for key in item.keys():
                        self.window.addstr(line, 0, f'{key}: {item[key]}', curses.color_pair(3))
                        line = line + 1
                    if self.download:
                        mb_download_file(sha256)
                        self.download = False
            else:
                if not self.selected:
                    self.window.addstr(idx, 0, f'{firstseen} | {sha256} | {filetype}\t| {tags}', curses.color_pair(1))
        self.window.refresh()


def mb_get_recent():
    data = {'query': 'get_recent', 'selector': 100}
    r = requests.post('https://mb-api.abuse.ch/api/v1/', data=data, timeout=15)
    return r.json()


def mb_download_file(sha256hash):
    data = {'query': 'get_file', 'sha256_hash': sha256hash}
    filename = f'{sha256hash}.zip'
    with requests.post('https://mb-api.abuse.ch/api/v1/', data=data, timeout=15, stream=True) as r:
        r.raise_for_status()
        with open(filename, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192):
                f.write(chunk)


def main():
    items = mb_get_recent()['data']
    screen = Screen(items)
    screen.run()


if __name__ == '__main__':
    main()